:py:mod:`aim2dat.aiida_workflows.cp2k.combined_work_chains`
===========================================================

.. py:module:: aim2dat.aiida_workflows.cp2k.combined_work_chains

.. autoapi-nested-parse::

   Aiida workchains for cp2k to run advanced tasks combining different basic workchains.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain
   aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain




Attributes
~~~~~~~~~~

.. autoapisummary::

   aim2dat.aiida_workflows.cp2k.combined_work_chains.BandStructureWC
   aim2dat.aiida_workflows.cp2k.combined_work_chains.CellOptWC
   aim2dat.aiida_workflows.cp2k.combined_work_chains.Cp2kCalculation
   aim2dat.aiida_workflows.cp2k.combined_work_chains.EigenvaluesWC
   aim2dat.aiida_workflows.cp2k.combined_work_chains.FindSCFParametersWC
   aim2dat.aiida_workflows.cp2k.combined_work_chains.GeoOptWC
   aim2dat.aiida_workflows.cp2k.combined_work_chains.PDOSWC
   aim2dat.aiida_workflows.cp2k.combined_work_chains.PartialChargesWC
   aim2dat.aiida_workflows.cp2k.combined_work_chains.StructureData
   aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceData



.. py:class:: ElectronicPropertiesWorkChain(inputs: dict | None = None, logger: logging.Logger | None = None, runner: aiida.engine.runners.Runner | None = None, enable_persistence: bool = True)


   Bases: :py:obj:`aiida.engine.WorkChain`

   Work chain to optimize the unit cell and calculate different electronic properties.

   
   .. py:class:: SaveKeys


      Bases: :py:obj:`enum.Enum`

      Keys used to identify things in the saved instance state bundle.


      .. rubric:: Overview


      .. list-table:: Methods
         :header-rows: 0
         :widths: auto

         * - :py:obj:`name <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.SaveKeys.name>`\ ()
           - The name of the Enum member.
         * - :py:obj:`value <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.SaveKeys.value>`\ ()
           - The value of the Enum member.


      .. py:attribute:: CALC_ID
         :type: str
         :value: 'calc_id'

         



      .. py:method:: name()

         The name of the Enum member.


      .. py:method:: value()

         The value of the Enum member.




   .. rubric:: Overview

   .. list-table:: Properties
      :header-rows: 0
      :widths: auto

      * - :py:obj:`ctx <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.ctx>`
        - Get the context.
      * - :py:obj:`inputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.inputs>`
        - Return the inputs attribute dictionary or an empty one.
      * - :py:obj:`metadata <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.metadata>`
        - Return the metadata that were specified when this process instance was launched.
      * - :py:obj:`node <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.node>`
        - Return the ProcessNode used by this process to represent itself in the database.
      * - :py:obj:`runner <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.runner>`
        - Get process runner.
      * - :py:obj:`uuid <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.uuid>`
        - Return the UUID of the process which corresponds to the UUID of its associated `ProcessNode`.


   .. list-table:: Methods
      :header-rows: 0
      :widths: auto

      * - :py:obj:`build_process_type <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.build_process_type>`\ ()
        - `class` The process type.
      * - :py:obj:`decode_input_args <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.decode_input_args>`\ (encoded)
        - Decode saved input arguments as they came from the saved instance state Bundle
      * - :py:obj:`define <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.define>`\ (spec)
        - `class` Specify inputs and outputs.
      * - :py:obj:`dft_cell_opt <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.dft_cell_opt>`\ ()
        - Perform the cell relaxation.
      * - :py:obj:`electronic_structure <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.electronic_structure>`\ ()
        - Calculate the electronic properties of the crystal.
      * - :py:obj:`encode_input_args <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.encode_input_args>`\ (inputs)
        - Encode input arguments such that they may be saved in a Bundle
      * - :py:obj:`exit_codes <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.exit_codes>`\ ()
        - Return the namespace of exit codes defined for this WorkChain through its ProcessSpec.
      * - :py:obj:`exposed_inputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.exposed_inputs>`\ (process_class, namespace, agglomerate)
        - Gather a dictionary of the inputs that were exposed for a given Process class under an optional namespace.
      * - :py:obj:`exposed_outputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.exposed_outputs>`\ (node, process_class, namespace, agglomerate)
        - Return the outputs which were exposed from the ``process_class`` and emitted by the specific ``node``
      * - :py:obj:`find_scf_parameters <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.find_scf_parameters>`\ ()
        - Find mixing parameters that converge the Kohn-Sham equations.
      * - :py:obj:`get_builder <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.get_builder>`\ ()
        - `class` \-
      * - :py:obj:`get_exit_statuses <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.get_exit_statuses>`\ (exit_code_labels)
        - `class` Return the exit status (integers) for the given exit code labels.
      * - :py:obj:`get_or_create_db_record <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.get_or_create_db_record>`\ ()
        - `class` Create a process node that represents what happened in this process.
      * - :py:obj:`get_parent_calc <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.get_parent_calc>`\ ()
        - Get the parent process node
      * - :py:obj:`get_provenance_inputs_iterator <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.get_provenance_inputs_iterator>`\ ()
        - Get provenance input iterator.
      * - :py:obj:`init <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.init>`\ ()
        - \-
      * - :py:obj:`is_valid_cache <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.is_valid_cache>`\ (node)
        - `class` Check if the given node can be cached from.
      * - :py:obj:`kill <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.kill>`\ (msg)
        - Kill the process and all the children calculations it called
      * - :py:obj:`load_instance_state <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.load_instance_state>`\ (saved_state, load_context)
        - Load instance state.
      * - :py:obj:`on_create <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_create>`\ ()
        - Called when a Process is created.
      * - :py:obj:`on_entered <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_entered>`\ (from_state)
        - After entering a new state, save a checkpoint and update the latest process state change timestamp.
      * - :py:obj:`on_except <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_except>`\ (exc_info)
        - Log the exception by calling the report method with formatted stack trace from exception info object
      * - :py:obj:`on_exiting <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_exiting>`\ ()
        - Ensure that any unstored nodes in the context are stored, before the state is exited
      * - :py:obj:`on_finish <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_finish>`\ (result, successful)
        - Set the finish status on the process node.
      * - :py:obj:`on_output_emitting <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_output_emitting>`\ (output_port, value)
        - The process has emitted a value on the given output port.
      * - :py:obj:`on_paused <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_paused>`\ (msg)
        - The Process was paused so set the paused attribute on the process node
      * - :py:obj:`on_playing <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_playing>`\ ()
        - The Process was unpaused so remove the paused attribute on the process node
      * - :py:obj:`on_run <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_run>`\ ()
        - \-
      * - :py:obj:`on_terminated <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_terminated>`\ ()
        - Called when a Process enters a terminal state.
      * - :py:obj:`on_wait <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.on_wait>`\ (awaitables)
        - Entering the WAITING state.
      * - :py:obj:`out <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.out>`\ (output_port, value)
        - Attach output to output port.
      * - :py:obj:`out_many <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.out_many>`\ (out_dict)
        - Attach outputs to multiple output ports.
      * - :py:obj:`post_processing <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.post_processing>`\ ()
        - Post-processing routine.
      * - :py:obj:`report <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.report>`\ (msg, \*args, \*\*kwargs)
        - Log a message to the logger, which should get saved to the database through the attached DbLogHandler.
      * - :py:obj:`run <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.run>`\ ()
        - \-
      * - :py:obj:`run_el_prop_wc <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.run_el_prop_wc>`\ (task_label, work_chain, structure, remote_folder, scf_parameters, extra_input)
        - Run electronic properties calculation.
      * - :py:obj:`save_instance_state <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.save_instance_state>`\ (out_state, save_context)
        - Save instance state.
      * - :py:obj:`set_input_parameter <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.set_input_parameter>`\ (work_chain_builder, input_key, value)
        - `static` Set input parameter for a child work chain.
      * - :py:obj:`set_status <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.set_status>`\ (status)
        - The status of the Process is about to be changed, so we reflect this is in node's attribute proxy.
      * - :py:obj:`setup <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.setup>`\ ()
        - Set up calculation parameters.
      * - :py:obj:`should_run_cell_opt <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.should_run_cell_opt>`\ ()
        - Whether to run a cell optimization.
      * - :py:obj:`spec <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.spec>`\ ()
        - `class` \-
      * - :py:obj:`spec_metadata <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.spec_metadata>`\ ()
        - Return the metadata port namespace of the process specification of this process.
      * - :py:obj:`submit <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.submit>`\ (process, \*\*kwargs)
        - Submit process for execution.
      * - :py:obj:`to_context <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.to_context>`\ (\*\*kwargs)
        - Add a dictionary of awaitables to the context.
      * - :py:obj:`update_outputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.ElectronicPropertiesWorkChain.update_outputs>`\ ()
        - Attach new outputs to the node since the last call.


   .. py:attribute:: SINGLE_OUTPUT_LINKNAME
      :type: str
      :value: 'result'

      


   .. py:property:: ctx
      :type: aiida.common.extendeddicts.AttributeDict

      Get the context.

   .. py:property:: inputs
      :type: plumpy.utils.AttributesFrozendict

      Return the inputs attribute dictionary or an empty one.

      This overrides the property of the base class because that can also return ``None``. This override ensures
      calling functions that they will always get an instance of ``AttributesFrozenDict``.

   .. py:property:: metadata
      :type: aiida.common.extendeddicts.AttributeDict

      Return the metadata that were specified when this process instance was launched.

      :return: metadata dictionary

   .. py:property:: node
      :type: aiida.orm.WorkChainNode

      Return the ProcessNode used by this process to represent itself in the database.

      :return: instance of sub class of ProcessNode

   .. py:property:: runner
      :type: aiida.engine.runners.Runner

      Get process runner.

   .. py:property:: uuid
      :type: str

      Return the UUID of the process which corresponds to the UUID of its associated `ProcessNode`.

      :return: the UUID associated to this process instance


   .. py:method:: build_process_type() -> str
      :classmethod:

      The process type.

      :return: string of the process type

      Note: This could be made into a property 'process_type' but in order to have it be a property of the class
      it would need to be defined in the metaclass, see https://bugs.python.org/issue20659


   .. py:method:: decode_input_args(encoded: str) -> Dict[str, Any]

      Decode saved input arguments as they came from the saved instance state Bundle

      :param encoded: encoded (serialized) inputs
      :return: The decoded input args


   .. py:method:: define(spec)
      :classmethod:

      Specify inputs and outputs.


   .. py:method:: dft_cell_opt()

      Perform the cell relaxation.


   .. py:method:: electronic_structure()

      Calculate the electronic properties of the crystal.


   .. py:method:: encode_input_args(inputs: Dict[str, Any]) -> str

      Encode input arguments such that they may be saved in a Bundle

      :param inputs: A mapping of the inputs as passed to the process
      :return: The encoded (serialized) inputs


   .. py:method:: exit_codes() -> aiida.engine.processes.exit_code.ExitCodesNamespace

      Return the namespace of exit codes defined for this WorkChain through its ProcessSpec.

      The namespace supports getitem and getattr operations with an ExitCode label to retrieve a specific code.
      Additionally, the namespace can also be called with either the exit code integer status to retrieve it.

      :returns: ExitCodesNamespace of ExitCode named tuples



   .. py:method:: exposed_inputs(process_class: Type[Process], namespace: Optional[str] = None, agglomerate: bool = True) -> aiida.common.extendeddicts.AttributeDict

      Gather a dictionary of the inputs that were exposed for a given Process class under an optional namespace.

      :param process_class: Process class whose inputs to try and retrieve
      :param namespace: PortNamespace in which to look for the inputs
      :param agglomerate: If set to true, all parent namespaces of the given ``namespace`` will also be
          searched for inputs. Inputs in lower-lying namespaces take precedence.

      :returns: exposed inputs



   .. py:method:: exposed_outputs(node: aiida.orm.ProcessNode, process_class: Type[Process], namespace: Optional[str] = None, agglomerate: bool = True) -> aiida.common.extendeddicts.AttributeDict

      Return the outputs which were exposed from the ``process_class`` and emitted by the specific ``node``

      :param node: process node whose outputs to try and retrieve
      :param namespace: Namespace in which to search for exposed outputs.
      :param agglomerate: If set to true, all parent namespaces of the given ``namespace`` will also
          be searched for outputs. Outputs in lower-lying namespaces take precedence.

      :returns: exposed outputs



   .. py:method:: find_scf_parameters()

      Find mixing parameters that converge the Kohn-Sham equations.


   .. py:method:: get_builder() -> aiida.engine.processes.builder.ProcessBuilder
      :classmethod:


   .. py:method:: get_exit_statuses(exit_code_labels: Iterable[str]) -> List[int]
      :classmethod:

      Return the exit status (integers) for the given exit code labels.

      :param exit_code_labels: a list of strings that reference exit code labels of this process class
      :return: list of exit status integers that correspond to the given exit code labels
      :raises AttributeError: if at least one of the labels does not correspond to an existing exit code


   .. py:method:: get_or_create_db_record() -> aiida.orm.ProcessNode
      :classmethod:

      Create a process node that represents what happened in this process.

      :return: A process node


   .. py:method:: get_parent_calc() -> Optional[aiida.orm.ProcessNode]

      Get the parent process node

      :return: the parent process node if there is one



   .. py:method:: get_provenance_inputs_iterator() -> Iterator[Tuple[str, Union[aiida.engine.processes.ports.InputPort, aiida.engine.processes.ports.PortNamespace]]]

      Get provenance input iterator.

      :rtype: filter


   .. py:method:: init() -> None


   .. py:method:: is_valid_cache(node: aiida.orm.ProcessNode) -> bool
      :classmethod:

      Check if the given node can be cached from.

      Overriding this method allows ``Process`` sub-classes to modify when
      corresponding process nodes are considered as a cache.

      .. warning :: When overriding this method, make sure to return ``False``
          *at least* in all cases when ``super()._node.base.caching.is_valid_cache(node)``
          returns ``False``. Otherwise, the ``invalidates_cache`` keyword on exit
          codes may have no effect.



   .. py:method:: kill(msg: Union[str, None] = None) -> Union[bool, plumpy.futures.Future]

      Kill the process and all the children calculations it called

      :param msg: message


   .. py:method:: load_instance_state(saved_state, load_context)

      Load instance state.

      :param saved_state: saved instance state
      :param load_context:



   .. py:method:: on_create() -> None

      Called when a Process is created.


   .. py:method:: on_entered(from_state: Optional[plumpy.process_states.State]) -> None

      After entering a new state, save a checkpoint and update the latest process state change timestamp.


   .. py:method:: on_except(exc_info: Tuple[Any, Exception, types.TracebackType]) -> None

      Log the exception by calling the report method with formatted stack trace from exception info object
      and store the exception string as a node attribute

      :param exc_info: the sys.exc_info() object (type, value, traceback)


   .. py:method:: on_exiting() -> None

      Ensure that any unstored nodes in the context are stored, before the state is exited

      After the state is exited the next state will be entered and if persistence is enabled, a checkpoint will
      be saved. If the context contains unstored nodes, the serialization necessary for checkpointing will fail.


   .. py:method:: on_finish(result: Union[int, aiida.engine.processes.exit_code.ExitCode, None], successful: bool) -> None

      Set the finish status on the process node.

      :param result: result of the process
      :param successful: whether execution was successful



   .. py:method:: on_output_emitting(output_port: str, value: Any) -> None

      The process has emitted a value on the given output port.

      :param output_port: The output port name the value was emitted on
      :param value: The value emitted



   .. py:method:: on_paused(msg: Optional[str] = None) -> None

      The Process was paused so set the paused attribute on the process node

      :param msg: message



   .. py:method:: on_playing() -> None

      The Process was unpaused so remove the paused attribute on the process node


   .. py:method:: on_run()


   .. py:method:: on_terminated() -> None

      Called when a Process enters a terminal state.


   .. py:method:: on_wait(awaitables: Sequence[Awaitable])

      Entering the WAITING state.


   .. py:method:: out(output_port: str, value: Any = None) -> None

      Attach output to output port.

      The name of the port will be used as the link label.

      :param output_port: name of output port
      :param value: value to put inside output port



   .. py:method:: out_many(out_dict: Dict[str, Any]) -> None

      Attach outputs to multiple output ports.

      Keys of the dictionary will be used as output port names, values as outputs.

      :param out_dict: output dictionary
      :type out_dict: dict


   .. py:method:: post_processing()

      Post-processing routine.


   .. py:method:: report(msg: str, *args, **kwargs) -> None

      Log a message to the logger, which should get saved to the database through the attached DbLogHandler.

      The pk, class name and function name of the caller are prepended to the given message

      :param msg: message to log
      :param args: args to pass to the log call
      :param kwargs: kwargs to pass to the log call



   .. py:method:: run() -> Any


   .. py:method:: run_el_prop_wc(task_label, work_chain, structure, remote_folder, scf_parameters, extra_input)

      Run electronic properties calculation.


   .. py:method:: save_instance_state(out_state, save_context)

      Save instance state.

      :param out_state: state to save in

      :param save_context:
      :type save_context: :class:`!plumpy.persistence.LoadSaveContext`



   .. py:method:: set_input_parameter(work_chain_builder, input_key, value)
      :staticmethod:

      Set input parameter for a child work chain.


   .. py:method:: set_status(status: Optional[str]) -> None

      The status of the Process is about to be changed, so we reflect this is in node's attribute proxy.

      :param status: the status message



   .. py:method:: setup()

      Set up calculation parameters.


   .. py:method:: should_run_cell_opt()

      Whether to run a cell optimization.


   .. py:method:: spec() -> WorkChainSpec
      :classmethod:


   .. py:method:: spec_metadata() -> aiida.engine.processes.ports.PortNamespace

      Return the metadata port namespace of the process specification of this process.


   .. py:method:: submit(process: Type[Process], **kwargs) -> aiida.orm.ProcessNode

      Submit process for execution.

      :param process: process
      :return: the calculation node of the process



   .. py:method:: to_context(**kwargs: aiida.engine.processes.workchains.awaitable.Awaitable | aiida.orm.ProcessNode) -> None

      Add a dictionary of awaitables to the context.

      This is a convenience method that provides syntactic sugar, for a user to add multiple intersteps that will
      assign a certain value to the corresponding key in the context of the work chain.


   .. py:method:: update_outputs() -> None

      Attach new outputs to the node since the last call.

      Does nothing, if self.metadata.store_provenance is False.




.. py:class:: SurfaceOptWorkChain(inputs: dict | None = None, logger: logging.Logger | None = None, runner: aiida.engine.runners.Runner | None = None, enable_persistence: bool = True)


   Bases: :py:obj:`aiida.engine.WorkChain`

   Work chain to converge the slab size and optimize the atomic positions of the converged
   slab.

   
   .. py:class:: SaveKeys


      Bases: :py:obj:`enum.Enum`

      Keys used to identify things in the saved instance state bundle.


      .. rubric:: Overview


      .. list-table:: Methods
         :header-rows: 0
         :widths: auto

         * - :py:obj:`name <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.SaveKeys.name>`\ ()
           - The name of the Enum member.
         * - :py:obj:`value <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.SaveKeys.value>`\ ()
           - The value of the Enum member.


      .. py:attribute:: CALC_ID
         :type: str
         :value: 'calc_id'

         



      .. py:method:: name()

         The name of the Enum member.


      .. py:method:: value()

         The value of the Enum member.




   .. rubric:: Overview

   .. list-table:: Properties
      :header-rows: 0
      :widths: auto

      * - :py:obj:`ctx <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.ctx>`
        - Get the context.
      * - :py:obj:`inputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.inputs>`
        - Return the inputs attribute dictionary or an empty one.
      * - :py:obj:`metadata <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.metadata>`
        - Return the metadata that were specified when this process instance was launched.
      * - :py:obj:`node <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.node>`
        - Return the ProcessNode used by this process to represent itself in the database.
      * - :py:obj:`runner <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.runner>`
        - Get process runner.
      * - :py:obj:`uuid <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.uuid>`
        - Return the UUID of the process which corresponds to the UUID of its associated `ProcessNode`.


   .. list-table:: Methods
      :header-rows: 0
      :widths: auto

      * - :py:obj:`build_process_type <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.build_process_type>`\ ()
        - `class` The process type.
      * - :py:obj:`decode_input_args <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.decode_input_args>`\ (encoded)
        - Decode saved input arguments as they came from the saved instance state Bundle
      * - :py:obj:`define <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.define>`\ (spec)
        - `class` Specify inputs and outputs.
      * - :py:obj:`encode_input_args <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.encode_input_args>`\ (inputs)
        - Encode input arguments such that they may be saved in a Bundle
      * - :py:obj:`exit_codes <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.exit_codes>`\ ()
        - Return the namespace of exit codes defined for this WorkChain through its ProcessSpec.
      * - :py:obj:`exposed_inputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.exposed_inputs>`\ (process_class, namespace, agglomerate)
        - Gather a dictionary of the inputs that were exposed for a given Process class under an optional namespace.
      * - :py:obj:`exposed_outputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.exposed_outputs>`\ (node, process_class, namespace, agglomerate)
        - Return the outputs which were exposed from the ``process_class`` and emitted by the specific ``node``
      * - :py:obj:`find_scf_p <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.find_scf_p>`\ ()
        - Run the FindSCFParameters work chain.
      * - :py:obj:`geo_opt <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.geo_opt>`\ ()
        - Run the GeoOpt work chain.
      * - :py:obj:`geo_preopt <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.geo_preopt>`\ ()
        - Run the GeoOpt work chain.
      * - :py:obj:`get_builder <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.get_builder>`\ ()
        - `class` \-
      * - :py:obj:`get_exit_statuses <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.get_exit_statuses>`\ (exit_code_labels)
        - `class` Return the exit status (integers) for the given exit code labels.
      * - :py:obj:`get_or_create_db_record <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.get_or_create_db_record>`\ ()
        - `class` Create a process node that represents what happened in this process.
      * - :py:obj:`get_parent_calc <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.get_parent_calc>`\ ()
        - Get the parent process node
      * - :py:obj:`get_provenance_inputs_iterator <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.get_provenance_inputs_iterator>`\ ()
        - Get provenance input iterator.
      * - :py:obj:`init <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.init>`\ ()
        - \-
      * - :py:obj:`inspect_find_scf_p_results <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.inspect_find_scf_p_results>`\ ()
        - Check if the previous work chain finished successful.
      * - :py:obj:`inspect_geo_opt_results <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.inspect_geo_opt_results>`\ ()
        - Check if the previous work chain finished successful.
      * - :py:obj:`is_valid_cache <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.is_valid_cache>`\ (node)
        - `class` Check if the given node can be cached from.
      * - :py:obj:`kill <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.kill>`\ (msg)
        - Kill the process and all the children calculations it called
      * - :py:obj:`load_instance_state <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.load_instance_state>`\ (saved_state, load_context)
        - Load instance state.
      * - :py:obj:`on_create <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_create>`\ ()
        - Called when a Process is created.
      * - :py:obj:`on_entered <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_entered>`\ (from_state)
        - After entering a new state, save a checkpoint and update the latest process state change timestamp.
      * - :py:obj:`on_except <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_except>`\ (exc_info)
        - Log the exception by calling the report method with formatted stack trace from exception info object
      * - :py:obj:`on_exiting <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_exiting>`\ ()
        - Ensure that any unstored nodes in the context are stored, before the state is exited
      * - :py:obj:`on_finish <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_finish>`\ (result, successful)
        - Set the finish status on the process node.
      * - :py:obj:`on_output_emitting <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_output_emitting>`\ (output_port, value)
        - The process has emitted a value on the given output port.
      * - :py:obj:`on_paused <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_paused>`\ (msg)
        - The Process was paused so set the paused attribute on the process node
      * - :py:obj:`on_playing <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_playing>`\ ()
        - The Process was unpaused so remove the paused attribute on the process node
      * - :py:obj:`on_run <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_run>`\ ()
        - \-
      * - :py:obj:`on_terminated <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_terminated>`\ ()
        - Called when a Process enters a terminal state.
      * - :py:obj:`on_wait <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.on_wait>`\ (awaitables)
        - Entering the WAITING state.
      * - :py:obj:`out <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.out>`\ (output_port, value)
        - Attach output to output port.
      * - :py:obj:`out_many <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.out_many>`\ (out_dict)
        - Attach outputs to multiple output ports.
      * - :py:obj:`post_processing <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.post_processing>`\ ()
        - Define outputs.
      * - :py:obj:`report <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.report>`\ (msg, \*args, \*\*kwargs)
        - Log a message to the logger, which should get saved to the database through the attached DbLogHandler.
      * - :py:obj:`run <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.run>`\ ()
        - \-
      * - :py:obj:`save_instance_state <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.save_instance_state>`\ (out_state, save_context)
        - Save instance state.
      * - :py:obj:`set_status <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.set_status>`\ (status)
        - The status of the Process is about to be changed, so we reflect this is in node's attribute proxy.
      * - :py:obj:`setup <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.setup>`\ ()
        - Define initial parameters.
      * - :py:obj:`should_run_add_calc <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.should_run_add_calc>`\ ()
        - Check whether additional calculations are run after the slab size is converged.
      * - :py:obj:`should_run_slab_conv <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.should_run_slab_conv>`\ ()
        - Check whether the convergence criteria is fulfilled and the slab size is not
      * - :py:obj:`spec <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.spec>`\ ()
        - `class` \-
      * - :py:obj:`spec_metadata <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.spec_metadata>`\ ()
        - Return the metadata port namespace of the process specification of this process.
      * - :py:obj:`submit <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.submit>`\ (process, \*\*kwargs)
        - Submit process for execution.
      * - :py:obj:`to_context <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.to_context>`\ (\*\*kwargs)
        - Add a dictionary of awaitables to the context.
      * - :py:obj:`update_outputs <aim2dat.aiida_workflows.cp2k.combined_work_chains.SurfaceOptWorkChain.update_outputs>`\ ()
        - Attach new outputs to the node since the last call.


   .. py:attribute:: SINGLE_OUTPUT_LINKNAME
      :type: str
      :value: 'result'

      


   .. py:property:: ctx
      :type: aiida.common.extendeddicts.AttributeDict

      Get the context.

   .. py:property:: inputs
      :type: plumpy.utils.AttributesFrozendict

      Return the inputs attribute dictionary or an empty one.

      This overrides the property of the base class because that can also return ``None``. This override ensures
      calling functions that they will always get an instance of ``AttributesFrozenDict``.

   .. py:property:: metadata
      :type: aiida.common.extendeddicts.AttributeDict

      Return the metadata that were specified when this process instance was launched.

      :return: metadata dictionary

   .. py:property:: node
      :type: aiida.orm.WorkChainNode

      Return the ProcessNode used by this process to represent itself in the database.

      :return: instance of sub class of ProcessNode

   .. py:property:: runner
      :type: aiida.engine.runners.Runner

      Get process runner.

   .. py:property:: uuid
      :type: str

      Return the UUID of the process which corresponds to the UUID of its associated `ProcessNode`.

      :return: the UUID associated to this process instance


   .. py:method:: build_process_type() -> str
      :classmethod:

      The process type.

      :return: string of the process type

      Note: This could be made into a property 'process_type' but in order to have it be a property of the class
      it would need to be defined in the metaclass, see https://bugs.python.org/issue20659


   .. py:method:: decode_input_args(encoded: str) -> Dict[str, Any]

      Decode saved input arguments as they came from the saved instance state Bundle

      :param encoded: encoded (serialized) inputs
      :return: The decoded input args


   .. py:method:: define(spec)
      :classmethod:

      Specify inputs and outputs.


   .. py:method:: encode_input_args(inputs: Dict[str, Any]) -> str

      Encode input arguments such that they may be saved in a Bundle

      :param inputs: A mapping of the inputs as passed to the process
      :return: The encoded (serialized) inputs


   .. py:method:: exit_codes() -> aiida.engine.processes.exit_code.ExitCodesNamespace

      Return the namespace of exit codes defined for this WorkChain through its ProcessSpec.

      The namespace supports getitem and getattr operations with an ExitCode label to retrieve a specific code.
      Additionally, the namespace can also be called with either the exit code integer status to retrieve it.

      :returns: ExitCodesNamespace of ExitCode named tuples



   .. py:method:: exposed_inputs(process_class: Type[Process], namespace: Optional[str] = None, agglomerate: bool = True) -> aiida.common.extendeddicts.AttributeDict

      Gather a dictionary of the inputs that were exposed for a given Process class under an optional namespace.

      :param process_class: Process class whose inputs to try and retrieve
      :param namespace: PortNamespace in which to look for the inputs
      :param agglomerate: If set to true, all parent namespaces of the given ``namespace`` will also be
          searched for inputs. Inputs in lower-lying namespaces take precedence.

      :returns: exposed inputs



   .. py:method:: exposed_outputs(node: aiida.orm.ProcessNode, process_class: Type[Process], namespace: Optional[str] = None, agglomerate: bool = True) -> aiida.common.extendeddicts.AttributeDict

      Return the outputs which were exposed from the ``process_class`` and emitted by the specific ``node``

      :param node: process node whose outputs to try and retrieve
      :param namespace: Namespace in which to search for exposed outputs.
      :param agglomerate: If set to true, all parent namespaces of the given ``namespace`` will also
          be searched for outputs. Outputs in lower-lying namespaces take precedence.

      :returns: exposed outputs



   .. py:method:: find_scf_p()

      Run the FindSCFParameters work chain.


   .. py:method:: geo_opt()

      Run the GeoOpt work chain.


   .. py:method:: geo_preopt()

      Run the GeoOpt work chain.


   .. py:method:: get_builder() -> aiida.engine.processes.builder.ProcessBuilder
      :classmethod:


   .. py:method:: get_exit_statuses(exit_code_labels: Iterable[str]) -> List[int]
      :classmethod:

      Return the exit status (integers) for the given exit code labels.

      :param exit_code_labels: a list of strings that reference exit code labels of this process class
      :return: list of exit status integers that correspond to the given exit code labels
      :raises AttributeError: if at least one of the labels does not correspond to an existing exit code


   .. py:method:: get_or_create_db_record() -> aiida.orm.ProcessNode
      :classmethod:

      Create a process node that represents what happened in this process.

      :return: A process node


   .. py:method:: get_parent_calc() -> Optional[aiida.orm.ProcessNode]

      Get the parent process node

      :return: the parent process node if there is one



   .. py:method:: get_provenance_inputs_iterator() -> Iterator[Tuple[str, Union[aiida.engine.processes.ports.InputPort, aiida.engine.processes.ports.PortNamespace]]]

      Get provenance input iterator.

      :rtype: filter


   .. py:method:: init() -> None


   .. py:method:: inspect_find_scf_p_results()

      Check if the previous work chain finished successful.


   .. py:method:: inspect_geo_opt_results()

      Check if the previous work chain finished successful.


   .. py:method:: is_valid_cache(node: aiida.orm.ProcessNode) -> bool
      :classmethod:

      Check if the given node can be cached from.

      Overriding this method allows ``Process`` sub-classes to modify when
      corresponding process nodes are considered as a cache.

      .. warning :: When overriding this method, make sure to return ``False``
          *at least* in all cases when ``super()._node.base.caching.is_valid_cache(node)``
          returns ``False``. Otherwise, the ``invalidates_cache`` keyword on exit
          codes may have no effect.



   .. py:method:: kill(msg: Union[str, None] = None) -> Union[bool, plumpy.futures.Future]

      Kill the process and all the children calculations it called

      :param msg: message


   .. py:method:: load_instance_state(saved_state, load_context)

      Load instance state.

      :param saved_state: saved instance state
      :param load_context:



   .. py:method:: on_create() -> None

      Called when a Process is created.


   .. py:method:: on_entered(from_state: Optional[plumpy.process_states.State]) -> None

      After entering a new state, save a checkpoint and update the latest process state change timestamp.


   .. py:method:: on_except(exc_info: Tuple[Any, Exception, types.TracebackType]) -> None

      Log the exception by calling the report method with formatted stack trace from exception info object
      and store the exception string as a node attribute

      :param exc_info: the sys.exc_info() object (type, value, traceback)


   .. py:method:: on_exiting() -> None

      Ensure that any unstored nodes in the context are stored, before the state is exited

      After the state is exited the next state will be entered and if persistence is enabled, a checkpoint will
      be saved. If the context contains unstored nodes, the serialization necessary for checkpointing will fail.


   .. py:method:: on_finish(result: Union[int, aiida.engine.processes.exit_code.ExitCode, None], successful: bool) -> None

      Set the finish status on the process node.

      :param result: result of the process
      :param successful: whether execution was successful



   .. py:method:: on_output_emitting(output_port: str, value: Any) -> None

      The process has emitted a value on the given output port.

      :param output_port: The output port name the value was emitted on
      :param value: The value emitted



   .. py:method:: on_paused(msg: Optional[str] = None) -> None

      The Process was paused so set the paused attribute on the process node

      :param msg: message



   .. py:method:: on_playing() -> None

      The Process was unpaused so remove the paused attribute on the process node


   .. py:method:: on_run()


   .. py:method:: on_terminated() -> None

      Called when a Process enters a terminal state.


   .. py:method:: on_wait(awaitables: Sequence[Awaitable])

      Entering the WAITING state.


   .. py:method:: out(output_port: str, value: Any = None) -> None

      Attach output to output port.

      The name of the port will be used as the link label.

      :param output_port: name of output port
      :param value: value to put inside output port



   .. py:method:: out_many(out_dict: Dict[str, Any]) -> None

      Attach outputs to multiple output ports.

      Keys of the dictionary will be used as output port names, values as outputs.

      :param out_dict: output dictionary
      :type out_dict: dict


   .. py:method:: post_processing()

      Define outputs.


   .. py:method:: report(msg: str, *args, **kwargs) -> None

      Log a message to the logger, which should get saved to the database through the attached DbLogHandler.

      The pk, class name and function name of the caller are prepended to the given message

      :param msg: message to log
      :param args: args to pass to the log call
      :param kwargs: kwargs to pass to the log call



   .. py:method:: run() -> Any


   .. py:method:: save_instance_state(out_state, save_context)

      Save instance state.

      :param out_state: state to save in

      :param save_context:
      :type save_context: :class:`!plumpy.persistence.LoadSaveContext`



   .. py:method:: set_status(status: Optional[str]) -> None

      The status of the Process is about to be changed, so we reflect this is in node's attribute proxy.

      :param status: the status message



   .. py:method:: setup()

      Define initial parameters.


   .. py:method:: should_run_add_calc()

      Check whether additional calculations are run after the slab size is converged.


   .. py:method:: should_run_slab_conv()

      Check whether the convergence criteria is fulfilled and the slab size is not
      exceeding the maximum slab size.


   .. py:method:: spec() -> WorkChainSpec
      :classmethod:


   .. py:method:: spec_metadata() -> aiida.engine.processes.ports.PortNamespace

      Return the metadata port namespace of the process specification of this process.


   .. py:method:: submit(process: Type[Process], **kwargs) -> aiida.orm.ProcessNode

      Submit process for execution.

      :param process: process
      :return: the calculation node of the process



   .. py:method:: to_context(**kwargs: aiida.engine.processes.workchains.awaitable.Awaitable | aiida.orm.ProcessNode) -> None

      Add a dictionary of awaitables to the context.

      This is a convenience method that provides syntactic sugar, for a user to add multiple intersteps that will
      assign a certain value to the corresponding key in the context of the work chain.


   .. py:method:: update_outputs() -> None

      Attach new outputs to the node since the last call.

      Does nothing, if self.metadata.store_provenance is False.



.. py:data:: BandStructureWC

   

.. py:data:: CellOptWC

   

.. py:data:: Cp2kCalculation

   

.. py:data:: EigenvaluesWC

   

.. py:data:: FindSCFParametersWC

   

.. py:data:: GeoOptWC

   

.. py:data:: PDOSWC

   

.. py:data:: PartialChargesWC

   

.. py:data:: StructureData

   

.. py:data:: SurfaceData

   

