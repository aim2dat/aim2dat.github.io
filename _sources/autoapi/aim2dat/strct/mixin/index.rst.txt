:orphan:

:py:mod:`aim2dat.strct.mixin`
=============================

.. py:module:: aim2dat.strct.mixin

.. autoapi-nested-parse::

   Mixin classes for the Structure and StructureOperations classes.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   aim2dat.strct.mixin.AnalysisMixin
   aim2dat.strct.mixin.ConstraintsMixin
   aim2dat.strct.mixin.ManipulationMixin



Functions
~~~~~~~~~

.. autoapisummary::

   aim2dat.strct.mixin.analysis_method
   aim2dat.strct.mixin.manipulates_structure




.. py:exception:: ConstraintError


   Bases: :py:obj:`Exception`

   Constraint error.

   
   .. py:class:: args





   .. rubric:: Overview


   .. list-table:: Methods
      :header-rows: 0
      :widths: auto

      * - :py:obj:`with_traceback <aim2dat.strct.mixin.ConstraintError.with_traceback>`\ ()
        - Exception.with_traceback(tb) --




   .. py:method:: with_traceback()

      Exception.with_traceback(tb) --
      set self.__traceback__ to tb and return self.




.. py:class:: AnalysisMixin


   Mixin class to perform structural analysis tasks.


   .. rubric:: Overview

   .. list-table:: Properties
      :header-rows: 0
      :widths: auto

      * - :py:obj:`analysis_methods <aim2dat.strct.mixin.AnalysisMixin.analysis_methods>`
        - `class` Return calculation methods.


   .. list-table:: Methods
      :header-rows: 0
      :widths: auto

      * - :py:obj:`calculate_angle <aim2dat.strct.mixin.AnalysisMixin.calculate_angle>`\ (site_index1, site_index2, site_index3, backfold_positions)
        - Calculate angle between three atoms.
      * - :py:obj:`calculate_coordination <aim2dat.strct.mixin.AnalysisMixin.calculate_coordination>`\ (r_max, method, min_dist_delta, n_nearest_neighbours, radius_type, atomic_radius_delta, econ_tolerance, econ_conv_threshold, voronoi_weight_type, voronoi_weight_threshold, okeeffe_weight_threshold)
        - Calculate coordination environment of each atomic site.
      * - :py:obj:`calculate_dihedral_angle <aim2dat.strct.mixin.AnalysisMixin.calculate_dihedral_angle>`\ (site_index1, site_index2, site_index3, site_index4, backfold_positions)
        - Calculate dihedral angle between four atoms.
      * - :py:obj:`calculate_distance <aim2dat.strct.mixin.AnalysisMixin.calculate_distance>`\ (site_index1, site_index2, backfold_positions, use_supercell, r_max, return_pos)
        - Calculate distance between two atoms.
      * - :py:obj:`calculate_ffingerprint <aim2dat.strct.mixin.AnalysisMixin.calculate_ffingerprint>`\ (r_max, delta_bin, sigma, use_legacy_smearing, distinguish_kinds)
        - Calculate f-fingerprint function for each element-pair and atomic site.
      * - :py:obj:`calculate_voronoi_tessellation <aim2dat.strct.mixin.AnalysisMixin.calculate_voronoi_tessellation>`\ (r_max)
        - Calculate voronoi polyhedron for each atomic site.
      * - :py:obj:`determine_point_group <aim2dat.strct.mixin.AnalysisMixin.determine_point_group>`\ (threshold_distance, threshold_angle, threshold_inertia)
        - Determine the point group of a molecule.
      * - :py:obj:`determine_space_group <aim2dat.strct.mixin.AnalysisMixin.determine_space_group>`\ (symprec, angle_tolerance, hall_number, return_sym_operations, return_primitive_structure, return_standardized_structure, no_idealize)
        - Determine the space group of the structure using spglib as backend.



   .. py:property:: analysis_methods
      :type: list
      :classmethod:

      Return calculation methods.

      :type: list


   .. py:method:: calculate_angle(site_index1: int = 0, site_index2: int = 1, site_index3: int = 2, backfold_positions: bool = True) -> float

      Calculate angle between three atoms.

      :Parameters: * **site_index1** (*int*) -- Index of the site.
                   * **site_index2** (*int*) -- Index of the site.
                   * **site_index3** (*int*) -- Index of the site.
                   * **backfold_positions** (*bool*) -- Whether to backfold the atomic sites and return the smallest distance.

      :returns: *float* -- Angle calculated via the vectors from atom 2 to atom 1 and atom 3.


   .. py:method:: calculate_coordination(r_max: float = 10.0, method: str = 'minimum_distance', min_dist_delta: float = 0.1, n_nearest_neighbours: int = 5, radius_type: str = 'chen_manz', atomic_radius_delta: float = 0.0, econ_tolerance: float = 0.5, econ_conv_threshold: float = 0.001, voronoi_weight_type: float = 'rel_solid_angle', voronoi_weight_threshold: float = 0.5, okeeffe_weight_threshold: float = 0.5) -> dict

      Calculate coordination environment of each atomic site.

      :Parameters: * **r_max** (*float (optional)*) -- Cut-off value for the maximum distance between two atoms in angstrom.
                   * **method** (*str (optional)*) -- Method used to calculate the coordination environment. The default value is
                     ``'minimum_distance'``.
                   * **min_dist_delta** (*float (optional)*) -- Tolerance parameter that defines the relative distance from the nearest neighbour atom
                     for the ``'minimum_distance'`` method.
                   * **n_nearest_neighbours** (*int (optional)*) -- Number of neighbours that are considered coordinated for the ``'n_neighbours'``
                     method.
                   * **radius_type** (*str (optional)*) -- Type of the atomic radius used for the ``'atomic_radius'`` method (``'covalent'`` is
                     used as fallback in the radius for an element is not defined).
                   * **atomic_radius_delta** (*float (optional)*) -- Tolerance relative to the sum of the atomic radii for the ``'atomic_radius'`` method.
                     If set to ``0.0`` the maximum threshold is defined by the sum of the atomic radii,
                     positive (negative) values increase (decrease) the threshold.
                   * **econ_tolerance** (*float (optional)*) -- Tolerance parameter for the econ method.
                   * **econ_conv_threshold** (*float (optional)*) -- Convergence threshold for the econ method.
                   * **voronoi_weight_type** (*str (optional)*) -- Weight type of the Voronoi facets. Supported options are ``'covalent_atomic_radius'``,
                     ``'area'`` and ``'solid_angle'``. The prefix ``'rel_'`` specifies that the relative
                     weights with respect to the maximum value of the polyhedron are calculated.
                   * **voronoi_weight_threshold** (*float (optional)*) -- Weight threshold to consider a neighbouring atom coordinated.
                   * **okeeffe_weight_threshold** (*float (optional)*) -- Threshold parameter to distinguish indirect and direct neighbour atoms for the
                     ``'okeeffe'``.

                     This parameter is depreciated and will be removed in a future version.
                     The original results can be obtained by using the ``voronoi_weight_threshold``
                     parameter and setting ``voronoi_weight_type`` to ``'rel_solid_angle'``.

      :returns: *dict* -- Dictionary containing the coordination information of the structure.


   .. py:method:: calculate_dihedral_angle(site_index1: int = 0, site_index2: int = 1, site_index3: int = 2, site_index4: int = 3, backfold_positions: bool = True) -> float

      Calculate dihedral angle between four atoms.

      :Parameters: * **site_index1** (*int*) -- Index of the site.
                   * **site_index2** (*int*) -- Index of the site.
                   * **site_index3** (*int*) -- Index of the site.
                   * **site_index4** (*int*) -- Index of the site.
                   * **backfold_positions** (*bool*) -- Whether to backfold the atomic sites and return the smallest distance.

      :returns: *float* -- Dihedral angle.


   .. py:method:: calculate_distance(site_index1: Union[int, List[int]] = 0, site_index2: Union[int, List[int]] = 1, backfold_positions: bool = True, use_supercell: bool = False, r_max: float = 7.5, return_pos: bool = False) -> Union[float, list]

      Calculate distance between two atoms.

      :Parameters: * **site_index1** (*int*) -- Index of the site.
                   * **site_index2** (*int*) -- Index of the site.
                   * **backfold_positions** (*bool*) -- Whether to backfold the atomic sites and return the smallest distance.
                   * **use_supercell** (*bool*) -- User supercell to calculate all distances between the two atomic sites up to the
                     radius ``r_max``.
                   * **r_max** (*float*) -- Cut-off value for the maximum distance between two atoms in angstrom.
                   * **return_pos** (*bool*) -- Whether to return the positions. Useful if ``use_supercell`` is set to ``True`` or when
                     trying to determine the closest periodic image.

      :returns: *float or None* -- Distance between the two atoms or a list of distances (if ``use_super_cell`` is
                set to ``True``). If multiple indices are provided, a dictionary with the index pairs
                as keys is returned. If ``return_pos`` is set to ``True``, the positions are
                returned as well. In case ``use_super_cell`` is set to ``True`` and the distance
                between the two sites exceeds ``r_max``, ``None`` is returned.


   .. py:method:: calculate_ffingerprint(r_max: float = 20.0, delta_bin: float = 0.005, sigma: float = 0.05, use_legacy_smearing: bool = False, distinguish_kinds: bool = False) -> Tuple[dict, dict]

      Calculate f-fingerprint function for each element-pair and atomic site.

      The calculation is based on equation (3) in :doi:`10.1063/1.3079326`.

      :Parameters: * **r_max** (*float (optional)*) -- Cut-off value for the maximum distance between two atoms in angstrom.
                   * **delta_bin** (*float (optional)*) -- Bin size to descritize the function in angstrom.
                   * **sigma** (*float (optional)*) -- Smearing parameter for the Gaussian function.
                   * **use_legacy_smearing** (*bool*) -- Use the depreciated smearing method.
                   * **distinguish_kinds** (*bool (optional)*) -- Whether different kinds should be distinguished e.g. Ni0 and Ni1 would be considered as
                     different elements if ``True``.

      :returns: * **element_fingerprints** (*dict*) -- Dictionary containing all fingerprint functions of the structure summed over all atoms
                  of the same element.
                * **atomic_fingerprints** (*dict*) -- Dictionary containing all individual fingerprint functions for each atomic site.


   .. py:method:: calculate_voronoi_tessellation(r_max: float = 10.0) -> List[List[dict]]

      Calculate voronoi polyhedron for each atomic site.

      :Parameters: **r_max** (*float (optional)*) -- Cut-off value for the maximum distance between two atoms in angstrom.

      :returns: *list* -- List of voronoi details for each atomic site.


   .. py:method:: determine_point_group(threshold_distance: float = 0.1, threshold_angle: float = 1.0, threshold_inertia: float = 0.1) -> dict

      Determine the point group of a molecule.

      :Parameters: * **threshold_distance** (*float (optional)*) -- Tolerance parameter for distances.
                   * **threshold_angle** (*float (optional)*) -- Tolerance parameter for angles.
                   * **threshold_inertia** (*float (optional)*) -- Tolerance parameter for inertia.

      :returns: *dict* -- Dictionary containing the point group and symmetry elements of the structure.


   .. py:method:: determine_space_group(symprec: float = 0.005, angle_tolerance: float = -1.0, hall_number: int = 0, return_sym_operations: bool = False, return_primitive_structure: bool = False, return_standardized_structure: bool = False, no_idealize: bool = False) -> dict

      Determine the space group of the structure using spglib as backend.

      :Parameters: * **symprec** (*float (optional)*) -- Tolerance parameter for spglib
                   * **angle_tolerance** (*float (optional)*) -- Tolerance parameter for spglib.
                   * **hall_number** (*int (optional)*) -- The argument to constrain the space-group-type search only for the Hall symbol
                     corresponding to it.
                   * **return_sym_operations** (*bool (optional)*) -- Additionally, return all symmetry elements.
                   * **return_primitive_structure** (*bool (optional)*) -- Whether to return the primitive standardized structure.
                   * **return_standardized_structure** (*bool (optional)*) -- Whether to the non-primitive standardized structure.
                   * **no_idealize** (*bool (optional)*) -- Whether to idealize unit cell vectors and angles.

      :returns: *dict* -- Dictionary containing the internal space group number and labels.




.. py:class:: ConstraintsMixin


   Mixin to implement structural constraints.


   .. rubric:: Overview

   .. list-table:: Properties
      :header-rows: 0
      :widths: auto

      * - :py:obj:`attribute_constraints <aim2dat.strct.mixin.ConstraintsMixin.attribute_constraints>`
        - Attribute constraints.
      * - :py:obj:`chem_formula_constraints <aim2dat.strct.mixin.ConstraintsMixin.chem_formula_constraints>`
        - Constraints on the chemical formula.
      * - :py:obj:`concentration_constraints <aim2dat.strct.mixin.ConstraintsMixin.concentration_constraints>`
        - Elemental concentration constraints.
      * - :py:obj:`neglect_elemental_structures <aim2dat.strct.mixin.ConstraintsMixin.neglect_elemental_structures>`
        - Whether to neglect elemental phases.


   .. list-table:: Methods
      :header-rows: 0
      :widths: auto

      * - :py:obj:`add_chem_formula_constraint <aim2dat.strct.mixin.ConstraintsMixin.add_chem_formula_constraint>`\ (chem_formula, reduced_formula)
        - Add a chemical formula as a constraint.
      * - :py:obj:`remove_constraints <aim2dat.strct.mixin.ConstraintsMixin.remove_constraints>`\ ()
        - Remove all constraints.
      * - :py:obj:`set_attribute_constraint <aim2dat.strct.mixin.ConstraintsMixin.set_attribute_constraint>`\ (attribute, min_value, max_value)
        - Set a constraint on attributes.
      * - :py:obj:`set_concentration_constraint <aim2dat.strct.mixin.ConstraintsMixin.set_concentration_constraint>`\ (element, min_conc, max_conc)
        - Set a constraint on the concentration of an element in the structure.



   .. py:property:: attribute_constraints

      Attribute constraints.

   .. py:property:: chem_formula_constraints

      Constraints on the chemical formula.

   .. py:property:: concentration_constraints

      Elemental concentration constraints.

   .. py:property:: neglect_elemental_structures

      Whether to neglect elemental phases.


   .. py:method:: add_chem_formula_constraint(chem_formula, reduced_formula=True)

      Add a chemical formula as a constraint.

      The formula can be given as a string, dictionary or list of strings or dictionaries.

      :Parameters: * **chem_formula** (*list, dict or str*) -- Chemical formula given as list, dict or str.
                   * **reduced_formula** (*bool (optional)*) -- If set to ``True`` the reduced formulas are compared. The default value is ``True``.


   .. py:method:: remove_constraints()

      Remove all constraints.


   .. py:method:: set_attribute_constraint(attribute, min_value=None, max_value=None)

      Set a constraint on attributes.

      :Parameters: * **attribute** (*str*) -- Attribute to be constraint.
                   * **min_value** (*float*) -- Minimum value of the attribute. In case of no limit the variable can be set to ``0.0``.
                   * **max_value** (*float*) -- Maximum value of the attribute. In case of no limit the variable can be set to ``1.0``.


   .. py:method:: set_concentration_constraint(element, min_conc=0.0, max_conc=1.0)

      Set a constraint on the concentration of an element in the structure.

      The minimum and maximum values have to be set between 0.0 and 1.0.

      :Parameters: * **element** (*str*) -- Element to be constraint.
                   * **min_conc** (*float*) -- Minimum concentration. In case of no limit the variable can be set to ``0.0``.
                   * **max_conc** (*float*) -- Maximum concentration. In case of no limit the variable can be set to ``1.0``.




.. py:class:: ManipulationMixin


   Mixin class to perform structural manipulation tasks.


   .. rubric:: Overview

   .. list-table:: Properties
      :header-rows: 0
      :widths: auto

      * - :py:obj:`manipulation_methods <aim2dat.strct.mixin.ManipulationMixin.manipulation_methods>`
        - `class` Return manipulation methods.


   .. list-table:: Methods
      :header-rows: 0
      :widths: auto

      * - :py:obj:`delete_atoms <aim2dat.strct.mixin.ManipulationMixin.delete_atoms>`\ (elements, site_indices, change_label)
        - Delete atoms by element, list of elements, site index  or list of site indices.
      * - :py:obj:`perform_manipulation <aim2dat.strct.mixin.ManipulationMixin.perform_manipulation>`\ (method, kwargs)
        - Perform structure manipulation using an external method.
      * - :py:obj:`scale_unit_cell <aim2dat.strct.mixin.ManipulationMixin.scale_unit_cell>`\ (scaling_factor, change_label)
        - Scale unit cell of the structure.
      * - :py:obj:`substitute_elements <aim2dat.strct.mixin.ManipulationMixin.substitute_elements>`\ (elements, radius_type, remove_kind, change_label)
        - Substitute all atoms of one or several elements.



   .. py:property:: manipulation_methods
      :type: list
      :classmethod:

      Return manipulation methods.

      :type: list


   .. py:method:: delete_atoms(elements: Union[str, List[str]] = [], site_indices: Union[int, List[int]] = [], change_label: bool = False) -> Union[aim2dat.strct.Structure, aim2dat.strct.StructureCollection]

      Delete atoms by element, list of elements, site index  or list of site indices.

      :Parameters: * **elements** (*str, list or tuple*) -- Element or tuple or list of  the elements to be deleted.
                   * **site_indices** (*list or tuple*) -- Site index or tuple or list of site indices to be deleted.

      :returns: *aim2dat.strct.Structure* -- Structure with deleted atoms.


   .. py:method:: perform_manipulation(method: collections.abc.Callable, kwargs: dict = {})

      Perform structure manipulation using an external method.

      :Parameters: * **method** (*function*) -- Function which manipulates the structure(s).
                   * **kwargs** (*dict*) -- Arguments to be passed to the function.

      :returns: * *aim2dat.strct.Structure or*
                * *aim2dat.strct.StructureCollection* -- Manipulated structure(s).


   .. py:method:: scale_unit_cell(scaling_factor: float = 1.0, change_label: bool = False) -> Union[aim2dat.strct.Structure, aim2dat.strct.StructureCollection]

      Scale unit cell of the structure.

      :Parameters: **scaling_factor** (*float*) -- Scaling factor.

      :returns: *aim2dat.strct.Structure* -- Structure with scaled unit cell.


   .. py:method:: substitute_elements(elements: Union[List[Tuple[str]], List[Tuple[int]]] = [], radius_type: Union[str, None] = 'covalent', remove_kind: bool = False, change_label: bool = False) -> Union[aim2dat.strct.Structure, aim2dat.strct.StructureCollection]

      Substitute all atoms of one or several elements.

      :Parameters: * **elements** (*list or tuple*) -- Tuple or list of tuples of the elements that are substituted.
                   * **remove_kind** (*bool (optional)*) -- Sets the entries of the substituted sites in `kinds` to `None`.
                   * **radius_type** (*str or None (optional)*) -- Radius type used to calculate the scaling factor for the unit cell. If set to ``None``
                     no scaling is applied. The default value is ``covalent``.

      :returns: *aim2dat.strct.Structure* -- Structure with substituted elements.



.. py:function:: analysis_method(func)

   Mark function as calculation function.


.. py:function:: manipulates_structure(func)

   Mark structure manipulating functions.


